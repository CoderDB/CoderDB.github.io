---
layout: post
date: 2016-11-10
title: GCD入门
---

## 什么是GCD
- [ ] ~~什么是GCD~~

Grand Central Dispatch is a low-level framework in OS X that manages concurrent and asynchronous execution of tasks across the operating system. Essentially, tasks are queued and scheduled for execution as processor cores become available. By allowing the system to control the allocation of threads to tasks, GCD uses resources more effectively, which help the system and apps run faster, efficiently, and responsively.

GCD supports the implementation of dispatch queues, which execute arbitrary blocks of code asynchronously or synchronously. Use dispatch queues to perform nearly all of the tasks that could be performed on separate threads. Dispatch queues are easier and more efficient to use than the corresponding threaded code. Serial dispatch queues are a good alternative to using timers for synchronization.

---
##GCD术语
> * Serial(串行): FIFO 任务顺序执行
> * Concurrent(并发): 多个任务并发(同时)执行
> * Sync(同步): 在当前线程中执行任务
> * Async(异步): 在新的线程中执行任务

---
##创建队列
### 1. Serial 串行队列
```swift
let serialQueue = DispatchQueue(label: "serialQueue")
```
### 2. Concurrent 并发队列
```swift
let concurrentQueue = DispatchQueue(label: "concurrentQueue", attributes: DispatchQueue.Attributes.concurrent)
```

---
##GCD使用

### 1. Serial + Sync 串行同步
```swift
    func serialSync() {
        print("----\(Thread.current)")
        print("----\(1)")
        serialQueue.sync {
            print("====\(Thread.current)")
            print("====\(2)")
        }
        print("++++\(Thread.current)")
        print("++++\(3)")
    }
```
输出结果:
```
    ----<NSThread: 0x6000000658c0>{number = 1, name = main}
    ----1
    ====<NSThread: 0x6000000658c0>{number = 1, name = main}
    ====2
    ++++<NSThread: 0x6000000658c0>{number = 1, name = main}
    ++++3
```
> **串行同步，在当前线程中按顺序一次执行**

### 2. Serial + Async 串行异步
```
    func serialAsync() {
        print("----\(Thread.current)")
        print("----1")
        serialQueue.async {
            print("====\(Thread.current)")
            print("====2")
        }
        print("++++\(Thread.current)")
        print("++++3")
    }
```
输出结果:
```
    ----<NSThread: 0x170261a40>{number = 1, name = main}
    ----1
    ++++<NSThread: 0x170261a40>{number = 1, name = main}
    ++++3
    ====<NSThread: 0x174264340>{number = 5, name = (null)}
    ====2
```
> **串行队列，异步执行，会开线程，一定是先执行外部(当前线程)，再执行block里面(新开线程)**

### 3. Concurrent + Sync 并发同步
```swift
    func concurrentSync() {
        print("----\(Thread.current)")
        print("----1")
        concurrentQueue.sync {
            print("====\(Thread.current)")
            print("====2")
        }
        print("++++\(Thread.current)")
        print("++++3")
    }
```
输出结果:
```
    ----<NSThread: 0x600000067bc0>{number = 1, name = main}
    ----1
    ====<NSThread: 0x600000067bc0>{number = 1, name = main}
    ====2
    ++++<NSThread: 0x600000067bc0>{number = 1, name = main}
    ++++3
```
> **并发同步，不会开线程，顺序执行**

### 4. Concurrent + ASync 并发异步
```swift
    func concurrentAsync() {
        print("----\(Thread.current)")
        print("----1")
        concurrentQueue.async {
            print("====\(Thread.current)")
            print("====2")
        }
        print("++++\(Thread.current)")
        print("++++3")
    }
```
输出结果:
```
    ----<NSThread: 0x174066400>{number = 1, name = main}
    ----1
    ++++<NSThread: 0x174066400>{number = 1, name = main}
    ++++3
    ====<NSThread: 0x17406e540>{number = 5, name = (null)}
    ====2
```
> **并发异步，会开线程，先执行block外**

---

## 总结
> * 同步执行不管是并发队列，还是串行队列，都不会开线程，都是顺序执行
> * 异步执行不管是并发队列，还是串行队列，都会开线程，都是先执行block外，在执行内
